@file:OptIn(ExperimentalSerializationApi::class)

package id.walt.openid4vp.verifier.data

import id.walt.crypto.keys.DirectSerializedKey
import id.walt.crypto.keys.KeyManager
import id.walt.dcql.models.ClaimsQuery
import id.walt.dcql.models.CredentialFormat
import id.walt.dcql.models.CredentialQuery
import id.walt.dcql.models.DcqlQuery
import id.walt.dcql.models.meta.MsoMdocMeta
import id.walt.dcql.models.meta.NoMeta
import id.walt.ktornotifications.core.KtorSessionNotifications
import id.walt.openid4vp.verifier.data.Verification2Session.DefinedVerificationPolicies
import id.walt.openid4vp.verifier.utils.UrlUtils
import id.walt.verifier.openid.models.authorization.ClientMetadata
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonClassDiscriminator
import kotlinx.serialization.json.JsonPrimitive

/**
 * Defines all properties common to every flow.
 */
@Serializable
data class GeneralFlowConfig(
    @SerialName("dcql_query")
    val dcqlQuery: DcqlQuery,

    @SerialName("signed_request")
    val signedRequest: Boolean = false,
    @SerialName("encrypted_response")
    val encryptedResponse: Boolean = false,

    val notifications: KtorSessionNotifications? = null,

    val policies: DefinedVerificationPolicies = DefinedVerificationPolicies(),

    @SerialName("client_metadata")
    val clientMetadata: ClientMetadata? = null,
    val clientId: String? = null,

    // Auto-generated by default
    val sessionId: String? = null,

    /** request signing key */
    val key: DirectSerializedKey? = null,
    /** certificate chain for signed request */
    val x5c: List<String>? = null
) {
    init {
        // Verify if DCQL Query is correct
        dcqlQuery.precheck()

        if (signedRequest) {
            requireNotNull(key) { "Requested signed request, but did not provide a key (to sign request with)!" }
        }

        if (encryptedResponse) {
            requireNotNull(key) { "Requested encrypted response, but did not provide a key (to decrypt response with)!" }
        }
    }
}

/**
 * Defines properties common to URL-based flows.
 */
@Serializable
data class UrlConfig(
    @SerialName("url_host")
    val urlHost: String? = null,
    @SerialName("url_prefix")
    val urlPrefix: String? = null
)

/**
 * The polymorphic base type. Implementations will be composed of the config blocks.
 */
@Serializable
@JsonClassDiscriminator("flow_type")
sealed interface VerificationSessionSetup {
    // Expose the common config for easy, unified access from any flow type.
    val core: GeneralFlowConfig
}

sealed interface UrlBearingDeviceFlowSetup : VerificationSessionSetup {
    val urlConfig: UrlConfig
}

/**
 * Cross-Device (Scanning a QR Code)
 * Requires a URL to host the QR code link and endpoints for the wallet to poll/post to.
 */
@Serializable
@SerialName("cross_device")
data class CrossDeviceFlowSetup(
    @SerialName("core_flow")
    override val core: GeneralFlowConfig,
    @SerialName("url_config")
    override val urlConfig: UrlConfig = UrlConfig(),

    // Properties unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects? = null // Optional final redirect
) : UrlBearingDeviceFlowSetup {
    companion object {

        private val BASE_EXAMPLE = CrossDeviceFlowSetup(
            core = GeneralFlowConfig(
                // stub DCQL query (to avoid creating invalid DCQL query)
                dcqlQuery = DcqlQuery(listOf(CredentialQuery("stub", CredentialFormat.AC_VP, meta = NoMeta)))
            ),
            urlConfig = UrlConfig(
            ),
            redirects = Verification2Session.VerificationSessionRedirects(
                successRedirectUri = "https://example.com/success",
                errorRedirectUri = "https://example.com/not-successful"
            )
        )

        val EXAMPLE_MDL_OR_PHOTOID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_CREDENTIAL_SET_MDL_OR_PHOTOID
            )
        )

        val EXAMPLE_SDJWT_PID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_SDJWT_PID
            )
        )
    }
}

/**
 * Same-Device (Redirecting to Wallet on the same device, e.g. phone)
 * Requires a specific redirect URI for the Wallet to return the user to.
 */
@Serializable
@SerialName("same_device")
data class SameDeviceFlowSetup(
    override val core: GeneralFlowConfig,
    override val urlConfig: UrlConfig,

    // Property unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects // Required for final redirect
) : UrlBearingDeviceFlowSetup

/**
 * Digital Credentials API (Browser/OS native)
 * Can be Standard or HAIP (High Assurance).
 */
@Serializable
@SerialName("dc_api")
data class DcApiFlowSetup(
    override val core: GeneralFlowConfig,

    // Properties unique to this flow:
    val expectedOrigins: List<String>,
    val haip: Boolean = false,
) : VerificationSessionSetup {
    init {
        if (haip) {
            require(core.encryptedResponse) { "To be compliant with profile HAIP, encrypted response must be enabled. Set 'encryptedResponse' to be true (in GeneralFlowConfig)." }
        }

        expectedOrigins.forEach { origin ->
            val parsedOrigin = UrlUtils.checkDcApiOriginUrl(origin)
            require(parsedOrigin.secureContext) { "Provided expected origin \"$origin\" is not a secure context. Use of HTTPS is required!" }
            require(!parsedOrigin.nonComplexTrailingSlash) { "Your provided expected origin \"${origin}\" has a trailing slash ('/' at the end), this will be silently dropped by OS handlers when using DC API. Remove the trailing slash to avoid errors." }
        }
    }

    companion object {
        val EXAMPLE_SIGNED_MDL = DcApiFlowSetup(
            core = GeneralFlowConfig(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_mdl",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.18013.5.1.mDL"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "age_over_21"))
                            )
                        )
                    )
                ),
                signedRequest = true,
                encryptedResponse = false,
                clientId = "x509_hash:abc-xyz-base64url-sha256-hash-of-der-x509-leaf",

                key = DirectSerializedKey(KeyManager.resolveSerializedKeyBlocking("""{"type":"jwk","jwk":{"kty":"EC","d":"AEb4k1BeTR9xt2NxYZggdzkFLLUkhyyWvyUOq3qSiwA","crv":"P-256","kid":"_nd-T2YRYLSmuKkJZlRI641zrCIJLTpiHeqMwXuvdug","x":"G_TgBc0BkmMipiQ_6gkamIn3mmp7hcTrZuyrLTmknP0","y":"VkRMZdXYXSMff5AJLrnHiN0x5MV6u_8vrAcytGUe4z4"}}"""))
            ),
            expectedOrigins = listOf("http://localhost:7003"),
            haip = false        )
        val EXAMPLE_SIGNED_ENCRYPTED_MDL = EXAMPLE_SIGNED_MDL.copy(core = EXAMPLE_SIGNED_MDL.core.copy(encryptedResponse = true))
        val EXAMPLE_SIGNED_PHOTOID = EXAMPLE_SIGNED_MDL.copy(
            core = EXAMPLE_SIGNED_MDL.core.copy(
                dcqlQuery =
                    DcqlQuery(
                        credentials = listOf(
                            CredentialQuery(
                                id = "my_photoid",
                                format = CredentialFormat.MSO_MDOC,
                                meta = MsoMdocMeta(doctypeValue = "org.iso.23220.photoid.1"),
                                claims = listOf(
                                    ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name_unicode")),
                                    ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name_unicode")),
                                    ClaimsQuery(path = listOf("org.iso.18013.5.1", "issuing_authority_unicode")),
                                    ClaimsQuery(path = listOf("org.iso.18013.5.1", "resident_postal_code")),
                                    ClaimsQuery(
                                        path = listOf("org.iso.18013.5.1", "issuing_country"),
                                        values = listOf(JsonPrimitive("AT"))
                                    ),
                                    ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "person_id")),
                                    ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "resident_street")),
                                    ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "administrative_number")),
                                    ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "travel_document_number")),
                                    ClaimsQuery(path = listOf("org.iso.23220.dtc.1", "dtc_version")),
                                    ClaimsQuery(path = listOf("org.iso.23220.dtc.1", "dtc_dg1")),
                                )
                            )
                        )
                    ),
                signedRequest = true,
                encryptedResponse = false,
            )
        )
    }
}
