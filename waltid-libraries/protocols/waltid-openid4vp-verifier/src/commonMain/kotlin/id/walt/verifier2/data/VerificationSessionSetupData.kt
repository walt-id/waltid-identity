@file:OptIn(ExperimentalSerializationApi::class)

package id.walt.verifier2.data

import id.walt.crypto.keys.DirectSerializedKey
import id.walt.crypto.keys.KeyManager
import id.walt.dcql.models.ClaimsQuery
import id.walt.dcql.models.CredentialFormat
import id.walt.dcql.models.CredentialQuery
import id.walt.dcql.models.DcqlQuery
import id.walt.dcql.models.meta.MsoMdocMeta
import id.walt.dcql.models.meta.NoMeta
import id.walt.ktornotifications.core.KtorSessionNotifications
import id.walt.verifier.openid.models.authorization.ClientMetadata
import id.walt.verifier2.data.Verification2Session.DefinedVerificationPolicies
import id.walt.verifier2.utils.UrlUtils
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonClassDiscriminator

/**
 * Defines all properties common to every flow.
 */
@Serializable
data class GeneralFlowConfig(
    @SerialName("dcql_query") val dcqlQuery: DcqlQuery,

    @SerialName("signed_request") val signedRequest: Boolean = false,
    @SerialName("encrypted_response") val encryptedResponse: Boolean = false,

    val notifications: KtorSessionNotifications? = null,

    val policies: DefinedVerificationPolicies = DefinedVerificationPolicies(),

    @SerialName("client_metadata") val clientMetadata: ClientMetadata? = null,
    val clientId: String? = null,

    // Auto-generated by default
    val sessionId: String? = null,

    /** request signing key */
    val key: DirectSerializedKey? = null,
    /** certificate chain for signed request */
    val x5c: List<String>? = null
) {
    init {
        // Verify if DCQL Query is correct
        dcqlQuery.precheck()
    }
}

/**
 * Defines properties common to URL-based flows.
 */
@Serializable
data class UrlConfig(
    @SerialName("url_host") val urlHost: String? = null, @SerialName("url_prefix") val urlPrefix: String? = null
)

/**
 * The polymorphic base type. Implementations will be composed of the config blocks.
 */
@Serializable
@JsonClassDiscriminator("flow_type")
sealed interface VerificationSessionSetup {
    // Expose the common config for easy, unified access from any flow type.
    val core: GeneralFlowConfig
}

sealed interface UrlBearingDeviceFlowSetup : VerificationSessionSetup {
    val urlConfig: UrlConfig
}

/**
 * Cross-Device (Scanning a QR Code)
 * Requires a URL to host the QR code link and endpoints for the wallet to poll/post to.
 */
@Serializable
@SerialName("cross_device")
data class CrossDeviceFlowSetup(
    @SerialName("core_flow") override val core: GeneralFlowConfig,
    @SerialName("url_config") override val urlConfig: UrlConfig = UrlConfig(),

    // Properties unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects? = null // Optional final redirect
) : UrlBearingDeviceFlowSetup {
    companion object {

        private val BASE_EXAMPLE = CrossDeviceFlowSetup(
            core = GeneralFlowConfig(
                // stub DCQL query (to avoid creating invalid DCQL query)
                dcqlQuery = DcqlQuery(listOf(CredentialQuery("stub", CredentialFormat.AC_VP, meta = NoMeta)))
            ), urlConfig = UrlConfig(
            ), redirects = Verification2Session.VerificationSessionRedirects(
                successRedirectUri = "https://example.com/success", errorRedirectUri = "https://example.com/not-successful"
            )
        )

        val EXAMPLE_MDL_OR_PHOTOID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_CREDENTIAL_SET_MDL_OR_PHOTOID
            )
        )

        val EXAMPLE_SDJWT_PID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_SDJWT_PID
            )
        )

        val EXAMPLE_ISO_PID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_ISO_PID
            )
        )
    }
}

/**
 * Same-Device (Redirecting to Wallet on the same device, e.g. phone)
 * Requires a specific redirect URI for the Wallet to return the user to.
 */
@Serializable
@SerialName("same_device")
data class SameDeviceFlowSetup(
    override val core: GeneralFlowConfig, override val urlConfig: UrlConfig,

    // Property unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects // Required for final redirect
) : UrlBearingDeviceFlowSetup

/**
 * Digital Credentials API (Browser/OS native)
 * Can be Standard or HAIP (High Assurance).
 */
@Serializable
@SerialName("dc_api")
data class DcApiFlowSetup(
    override val core: GeneralFlowConfig,

    // Properties unique to this flow:
    val expectedOrigins: List<String>,
    val haip: Boolean = false,
) : VerificationSessionSetup {
    init {
        if (haip) {
            require(core.encryptedResponse) { "To be compliant with profile HAIP, encrypted response must be enabled. Set 'encryptedResponse' to be true (in GeneralFlowConfig)." }
        }

        expectedOrigins.forEach { origin ->
            val parsedOrigin = UrlUtils.checkDcApiOriginUrl(origin)
            require(parsedOrigin.secureContext) { "Provided expected origin \"$origin\" is not a secure context. Use of HTTPS is required!" }
            require(!parsedOrigin.nonComplexTrailingSlash) { "Your provided expected origin \"${origin}\" has a trailing slash ('/' at the end), this will be silently dropped by OS handlers when using DC API. Remove the trailing slash to avoid errors." }
        }
    }

    companion object {
        val EXAMPLE_UNSIGNED_UNENCRYPTED_MDL = DcApiFlowSetup(
            core = GeneralFlowConfig(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_mdl",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.18013.5.1.mDL"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "age_over_21"))
                            )
                        )
                    )
                ),
                signedRequest = false,
                encryptedResponse = false,
                clientId = "x509_hash:OPpTDyXlg6WRu2-Qn4rpQcA9uVqSrNExCS8kCYUe09A",

                key = DirectSerializedKey(KeyManager.resolveSerializedKeyBlocking("""{"type":"jwk","jwk":{"kty":"EC","d":"AEb4k1BeTR9xt2NxYZggdzkFLLUkhyyWvyUOq3qSiwA","crv":"P-256","kid":"_nd-T2YRYLSmuKkJZlRI641zrCIJLTpiHeqMwXuvdug","x":"G_TgBc0BkmMipiQ_6gkamIn3mmp7hcTrZuyrLTmknP0","y":"VkRMZdXYXSMff5AJLrnHiN0x5MV6u_8vrAcytGUe4z4"}}"""))
            ),
            expectedOrigins = listOf("https://digital-credentials.walt.id"),
            haip = false
        )
        val EXAMPLE_UNSIGNED_ENCRYPTED_MDL = EXAMPLE_UNSIGNED_UNENCRYPTED_MDL.copy(
            core = EXAMPLE_UNSIGNED_UNENCRYPTED_MDL.core.copy(
                encryptedResponse = true
            )
        )

        val EXAMPLE_SIGNED_MDL = DcApiFlowSetup(
            core = GeneralFlowConfig(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_mdl",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.18013.5.1.mDL"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "age_over_21"))
                            )
                        )
                    )
                ),
                signedRequest = true,
                encryptedResponse = false,
                clientId = "x509_hash:kZ5SI3MAFaLDPRxza8xguw-o6b8LYfmP2ZvrqVSRWng",
                x5c = listOf(
                    "MIIB7TCCAZOgAwIBAgIUXrHFKoaAx6+CFOOHp6fZ7Rs2EzgwCgYIKoZIzj0EAwIwHTEbMBkGA1UEAwwSQ3VzdG9tSW50ZXJtZWRpYXRlMB4XDTI2MDEyMjE1NTY0OFoXDTI3MDEyMjE1NTY0OFowEzERMA8GA1UEAwwIVmVyaWZpZXIwgZswEAYHKoZIzj0CAQYFK4EEACMDgYYABAD1oOE9xUCHiQ/8UDdJGqeTM6e5SdewrYP0/BstuJcDqfxCIQ8wSvTKArn0iCE0aJVpXIxU4908vdQva3LU7kn9BQBJxQyonnLqp2fFzCoLe3RWVkX5szxa4EJmrsJW1wwtJBwmYVe+lToAqFnc30i3oCyhp/pyDQCEaj0fZ9ij6UMCp6N4MHYwDAYDVR0TAQH/BAIwADAOBgNVHQ8BAf8EBAMCB4AwFgYDVR0RBA8wDYILZXhhbXBsZS5jb20wHQYDVR0OBBYEFFAdasyU1haLdvQdEizJEaAO+cmWMB8GA1UdIwQYMBaAFGVh3m3K6y5gABHGIuD7ibTR+AG6MAoGCCqGSM49BAMCA0gAMEUCIQDT9GYMvTTyEOmKDvilHmgejcbLWQ6ACUzlmbZDk67ztAIge2kWDxRetz6xIDtnfg4vlCW6pLbdBWasMrfm1eppDww=",
                    "MIIBlzCCAT2gAwIBAgIUZFEF4iwIsLuJO7pJ9bU7vo9Dg3kwCgYIKoZIzj0EAwIwFTETMBEGA1UEAwwKQ3VzdG9tUm9vdDAeFw0yNjAxMjIxNTU1NDJaFw0zNjAxMjAxNTU1NDJaMB0xGzAZBgNVBAMMEkN1c3RvbUludGVybWVkaWF0ZTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABAvlBFSSRWetJJSj5rvGoXtPnfw97YRHbJj4/kspQbSwxVN3RtofsSu0DevrISGx2MCPqqxHXdfSeu9SKgen6IOjYzBhMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlYd5tyusuYAARxiLg+4m00fgBujAfBgNVHSMEGDAWgBQ+D1YkeDpF+qaxAhlnb3XSkGZWCTAKBggqhkjOPQQDAgNIADBFAiEA789kIQsGTa/GJEgYaOID9VVoO0PyeeYEwub7P0a1+ZICIHI9bYi72XTca9e8rqGJuYmKz8qEQodLvaXdgwCfQ4KZ"
                ),

                key = DirectSerializedKey(
                    KeyManager.resolveSerializedKeyBlocking(
                        """{"type":"jwk","jwk":{
                    "kty": "EC",
                    "crv": "P-521",
                    "x": "APWg4T3FQIeJD_xQN0kap5Mzp7lJ17Ctg_T8Gy24lwOp_EIhDzBK9MoCufSIITRolWlcjFTj3Ty91C9rctTuSf0F",
                    "y": "AEnFDKiecuqnZ8XMKgt7dFZWRfmzPFrgQmauwlbXDC0kHCZhV76VOgCoWdzfSLegLKGn-nINAIRqPR9n2KPpQwKn",
                    "d": "AZT9f0qOOSMQl25qXwvFs23rq0PIUOV1R8YcG1iqRNKEYYs5k8gXNNuud4W6amuItCGWCrKSXRoHmgj6C5NUDzhA"
                  }}"""
                    )
                )
            ),
            expectedOrigins = listOf("https://digital-credentials.walt.id"),
            haip = false
        )
        val EXAMPLE_SIGNED_ENCRYPTED_MDL = EXAMPLE_SIGNED_MDL.copy(
            core = EXAMPLE_SIGNED_MDL.core.copy(
                encryptedResponse = true
            )
        )

        val EXAMPLE_SIGNED_ENCRYPTED_PHOTOID = EXAMPLE_SIGNED_ENCRYPTED_MDL.copy(
            core = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.copy(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_photoid",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.23220.photoid.1"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "person_id"))
                            )
                        )
                    )
                ),
                signedRequest = true,
                encryptedResponse = true,
                key = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.key,
                x5c = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.x5c
            )
        )

        val EXAMPLE_SIGNED_ENCRYPTED_PID = EXAMPLE_SIGNED_ENCRYPTED_MDL.copy(
            core = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.copy(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_pid",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "eu.europa.ec.eudi.pid.1"),
                            claims = listOf(
                                "family_name",
                                "given_name",
                                "birth_date",
                                "age_birth_year",
                                "age_over_18",
                                "age_over_21",
                                "family_name_birth",
                                "given_name_birth",
                                "birth_place",
                                "birth_country",
                                "issuance_date",
                                "expiry_date",
                                "issuing_authority",
                                "issuing_country"
                            ).map { ClaimsQuery(path = listOf("eu.europa.ec.eudi.pid.1", it)) }
                        )
                    )
                ),
                signedRequest = true,
                encryptedResponse = true,
                key = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.key,
                x5c = EXAMPLE_SIGNED_ENCRYPTED_MDL.core.x5c
            )
        )
    }
}

/**
 * ISO 18013-7 Annex C (DC API) flow using the unified /verification-session endpoints.
 */
// TODO: Not optimal with such custom logic
@Serializable
@SerialName("dc_api-annex-c")
data class DcApiAnnexCFlowSetup(
    val docType: String,
    val requestedElements: Map<String, List<String>>,
    val policies: DefinedVerificationPolicies = DefinedVerificationPolicies(),
    val origin: String,
    @SerialName("core_flow") override val core: GeneralFlowConfig = buildAnnexCCore(docType, requestedElements, policies)
) : VerificationSessionSetup {
    init {
        val parsedOrigin = UrlUtils.checkDcApiOriginUrl(origin)
        require(parsedOrigin.secureContext) { "Provided origin \"$origin\" is not a secure context. Use of HTTPS is required!" }
        require(!parsedOrigin.nonComplexTrailingSlash) {
            "Your provided origin \"$origin\" has a trailing slash ('/' at the end), this will be silently dropped by OS handlers when using DC API. Remove the trailing slash to avoid errors."
        }

        val expectedCore = buildAnnexCCore(docType, requestedElements, policies)
        require(core.dcqlQuery == expectedCore.dcqlQuery) { "core_flow.dcql_query must match docType/requestedElements" }
        require(core.policies == expectedCore.policies) { "core_flow.policies must match policies" }
    }

    companion object {
        private fun buildAnnexCCore(
            docType: String, requestedElements: Map<String, List<String>>, policies: DefinedVerificationPolicies
        ): GeneralFlowConfig {
            val claims = requestedElements.entries.sortedBy { it.key }.flatMap { (namespace, elements) ->
                elements.distinct().sorted().map { elementId ->
                    ClaimsQuery(path = listOf(namespace, elementId))
                }
            }

            val dcqlQuery = DcqlQuery(
                credentials = listOf(
                    CredentialQuery(
                        id = "annex_c", format = CredentialFormat.MSO_MDOC, meta = MsoMdocMeta(doctypeValue = docType), claims = claims
                    )
                )
            )

            return GeneralFlowConfig(
                dcqlQuery = dcqlQuery, policies = policies
            )
        }

        val EXTENDED_MDL_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "org.iso.18013.5.1.mDL",
            requestedElements = mapOf(
                "org.iso.18013.5.1" to listOf(
                    "family_name",
                    "given_name",
                    "birth_date",
                    "issue_date",
                    "expiry_date",
                    "issuing_country",
                    "issuing_authority",
                    "driving_privileges",

                    "age_birth_year",
                    "age_over_18",
                    "age_over_21",
                    "age_over_65",

                    "issuing_jurisdiction",
                    "nationality"
                )
            ),
            origin = "https://digital-credentials.walt.id"
        )

        val EXTENDED_PHOTOID_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "org.iso.23220.photoid.1",
            requestedElements = mapOf(
                "org.iso.23220.1" to listOf(
                    "family_name",
                    "family_name_viz",
                    "given_name",
                    "given_name_viz",
                    "issue_date",
                    "expiry_date",
                    "issuing_authority_unicode",
                    "issuing_country",
                    "age_over_18",
                    "age_over_21",
                    "age_over_65",
                    "age_birth_year",
                    "portrait_capture_date",
                    "birthplace",
                    "name_at_birth",
                    "resident_address",
                    "resident_city",
                    "resident_postal_code",
                    "resident_country",
                    "resident_city_latin1",
                    "nationality",
                    "document_number",
                    "issuing_subdivision",
                    "family_name_latin1",
                    "given_name_latin1"
                ),
                "org.iso.23220.photoid.1" to listOf(
                    "person_id",
                    "birth_country",
                    "birth_state",
                    "birth_city",
                    "administrative_number",
                    "resident_street",
                    "resident_house_number",
                    "travel_document_type",
                    "travel_document_number",
                    "travel_document_mrz",
                    "resident_state"
                )
            ),
            origin = "https://digital-credentials.walt.id",
        )

        val EXTENDED_PID_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "eu.europa.ec.eudi.pid.1",
            requestedElements = mapOf(
                "eu.europa.ec.eudi.pid.1" to listOf(
                    "family_name",
                    "given_name",
                    "birth_date",
                    "age_birth_year",
                    "age_over_18",
                    "age_over_21",
                    "age_over_65",
                    "family_name_birth",
                    "given_name_birth",
                    "birth_place",
                    "birth_country",
                    "issuance_date",
                    "expiry_date",
                    "issuing_authority",
                    "issuing_country"
                )
            ),
            origin = "https://digital-credentials.walt.id",
        )
    }
}
