@file:OptIn(ExperimentalSerializationApi::class)

package id.walt.verifier2.data

import id.walt.crypto.keys.DirectSerializedKey
import id.walt.crypto.keys.KeyManager
import id.walt.dcql.models.ClaimsQuery
import id.walt.dcql.models.CredentialFormat
import id.walt.dcql.models.CredentialQuery
import id.walt.dcql.models.DcqlQuery
import id.walt.dcql.models.meta.MsoMdocMeta
import id.walt.dcql.models.meta.NoMeta
import id.walt.ktornotifications.core.KtorSessionNotifications
import id.walt.verifier.openid.models.authorization.ClientMetadata
import id.walt.verifier2.data.Verification2Session.DefinedVerificationPolicies
import id.walt.verifier2.utils.UrlUtils
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonClassDiscriminator
import kotlinx.serialization.json.JsonPrimitive

/**
 * Defines all properties common to every flow.
 */
@Serializable
data class GeneralFlowConfig(
    @SerialName("dcql_query") val dcqlQuery: DcqlQuery,

    @SerialName("signed_request") val signedRequest: Boolean = false,
    @SerialName("encrypted_response") val encryptedResponse: Boolean = false,

    val notifications: KtorSessionNotifications? = null,

    val policies: DefinedVerificationPolicies = DefinedVerificationPolicies(),

    @SerialName("client_metadata") val clientMetadata: ClientMetadata? = null,
    val clientId: String? = null,

    // Auto-generated by default
    val sessionId: String? = null,

    /** request signing key */
    val key: DirectSerializedKey? = null,
    /** certificate chain for signed request */
    val x5c: List<String>? = null
) {
    init {
        // Verify if DCQL Query is correct
        dcqlQuery.precheck()
    }
}

/**
 * Defines properties common to URL-based flows.
 */
@Serializable
data class UrlConfig(
    @SerialName("url_host") val urlHost: String? = null, @SerialName("url_prefix") val urlPrefix: String? = null
)

/**
 * The polymorphic base type. Implementations will be composed of the config blocks.
 */
@Serializable
@JsonClassDiscriminator("flow_type")
sealed interface VerificationSessionSetup {
    // Expose the common config for easy, unified access from any flow type.
    val core: GeneralFlowConfig
}

sealed interface UrlBearingDeviceFlowSetup : VerificationSessionSetup {
    val urlConfig: UrlConfig
}

/**
 * Cross-Device (Scanning a QR Code)
 * Requires a URL to host the QR code link and endpoints for the wallet to poll/post to.
 */
@Serializable
@SerialName("cross_device")
data class CrossDeviceFlowSetup(
    @SerialName("core_flow") override val core: GeneralFlowConfig,
    @SerialName("url_config") override val urlConfig: UrlConfig = UrlConfig(),

    // Properties unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects? = null // Optional final redirect
) : UrlBearingDeviceFlowSetup {
    companion object {

        private val BASE_EXAMPLE = CrossDeviceFlowSetup(
            core = GeneralFlowConfig(
                // stub DCQL query (to avoid creating invalid DCQL query)
                dcqlQuery = DcqlQuery(listOf(CredentialQuery("stub", CredentialFormat.AC_VP, meta = NoMeta)))
            ), urlConfig = UrlConfig(
            ), redirects = Verification2Session.VerificationSessionRedirects(
                successRedirectUri = "https://example.com/success", errorRedirectUri = "https://example.com/not-successful"
            )
        )

        val EXAMPLE_MDL_OR_PHOTOID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_CREDENTIAL_SET_MDL_OR_PHOTOID
            )
        )

        val EXAMPLE_SDJWT_PID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_SDJWT_PID
            )
        )

        val EXAMPLE_ISO_PID: VerificationSessionSetup = BASE_EXAMPLE.copy(
            core = BASE_EXAMPLE.core.copy(
                dcqlQuery = DcqlQuery.DcqlQueryExamples.EXAMPLE_ISO_PID
            )
        )
    }
}

/**
 * Same-Device (Redirecting to Wallet on the same device, e.g. phone)
 * Requires a specific redirect URI for the Wallet to return the user to.
 */
@Serializable
@SerialName("same_device")
data class SameDeviceFlowSetup(
    override val core: GeneralFlowConfig, override val urlConfig: UrlConfig,

    // Property unique to this flow
    val redirects: Verification2Session.VerificationSessionRedirects // Required for final redirect
) : UrlBearingDeviceFlowSetup

/**
 * Digital Credentials API (Browser/OS native)
 * Can be Standard or HAIP (High Assurance).
 */
@Serializable
@SerialName("dc_api")
data class DcApiFlowSetup(
    override val core: GeneralFlowConfig,

    // Properties unique to this flow:
    val expectedOrigins: List<String>,
    val haip: Boolean = false,
) : VerificationSessionSetup {
    init {
        if (haip) {
            require(core.encryptedResponse) { "To be compliant with profile HAIP, encrypted response must be enabled. Set 'encryptedResponse' to be true (in GeneralFlowConfig)." }
        }

        expectedOrigins.forEach { origin ->
            val parsedOrigin = UrlUtils.checkDcApiOriginUrl(origin)
            require(parsedOrigin.secureContext) { "Provided expected origin \"$origin\" is not a secure context. Use of HTTPS is required!" }
            require(!parsedOrigin.nonComplexTrailingSlash) { "Your provided expected origin \"${origin}\" has a trailing slash ('/' at the end), this will be silently dropped by OS handlers when using DC API. Remove the trailing slash to avoid errors." }
        }
    }

    companion object {
        val EXAMPLE_SIGNED_MDL = DcApiFlowSetup(
            core = GeneralFlowConfig(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_mdl",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.18013.5.1.mDL"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "age_over_21"))
                            )
                        )
                    )
                ), signedRequest = true, encryptedResponse = false, clientId = "x509_hash:abc-xyz-base64url-sha256-hash-of-der-x509-leaf",

                key = DirectSerializedKey(KeyManager.resolveSerializedKeyBlocking("""{"type":"jwk","jwk":{"kty":"EC","d":"AEb4k1BeTR9xt2NxYZggdzkFLLUkhyyWvyUOq3qSiwA","crv":"P-256","kid":"_nd-T2YRYLSmuKkJZlRI641zrCIJLTpiHeqMwXuvdug","x":"G_TgBc0BkmMipiQ_6gkamIn3mmp7hcTrZuyrLTmknP0","y":"VkRMZdXYXSMff5AJLrnHiN0x5MV6u_8vrAcytGUe4z4"}}"""))
            ), expectedOrigins = listOf("http://localhost:7003"), haip = false
        )
        val EXAMPLE_SIGNED_ENCRYPTED_MDL = EXAMPLE_SIGNED_MDL.copy(core = EXAMPLE_SIGNED_MDL.core.copy(encryptedResponse = true))
        val EXAMPLE_SIGNED_PHOTOID = EXAMPLE_SIGNED_MDL.copy(
            core = EXAMPLE_SIGNED_MDL.core.copy(
                dcqlQuery = DcqlQuery(
                    credentials = listOf(
                        CredentialQuery(
                            id = "my_photoid",
                            format = CredentialFormat.MSO_MDOC,
                            meta = MsoMdocMeta(doctypeValue = "org.iso.23220.photoid.1"),
                            claims = listOf(
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "family_name_unicode")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "given_name_unicode")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "issuing_authority_unicode")),
                                ClaimsQuery(path = listOf("org.iso.18013.5.1", "resident_postal_code")),
                                ClaimsQuery(
                                    path = listOf("org.iso.18013.5.1", "issuing_country"), values = listOf(JsonPrimitive("AT"))
                                ),
                                ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "person_id")),
                                ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "resident_street")),
                                ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "administrative_number")),
                                ClaimsQuery(path = listOf("org.iso.23220.photoid.1", "travel_document_number")),
                                ClaimsQuery(path = listOf("org.iso.23220.dtc.1", "dtc_version")),
                                ClaimsQuery(path = listOf("org.iso.23220.dtc.1", "dtc_dg1")),
                            )
                        )
                    )
                ),
                signedRequest = true,
                encryptedResponse = false,
            )
        )
    }
}

/**
 * ISO 18013-7 Annex C (DC API) flow using the unified /verification-session endpoints.
 */
// TODO: Not optimal with such custom logic
@Serializable
@SerialName("dc_api-annex-c")
data class DcApiAnnexCFlowSetup(
    val docType: String,
    val requestedElements: Map<String, List<String>>,
    val policies: DefinedVerificationPolicies = DefinedVerificationPolicies(),
    val origin: String,
    @SerialName("core_flow") override val core: GeneralFlowConfig = buildAnnexCCore(docType, requestedElements, policies)
) : VerificationSessionSetup {
    init {
        val parsedOrigin = UrlUtils.checkDcApiOriginUrl(origin)
        require(parsedOrigin.secureContext) { "Provided origin \"$origin\" is not a secure context. Use of HTTPS is required!" }
        require(!parsedOrigin.nonComplexTrailingSlash) {
            "Your provided origin \"$origin\" has a trailing slash ('/' at the end), this will be silently dropped by OS handlers when using DC API. Remove the trailing slash to avoid errors."
        }

        val expectedCore = buildAnnexCCore(docType, requestedElements, policies)
        require(core.dcqlQuery == expectedCore.dcqlQuery) { "core_flow.dcql_query must match docType/requestedElements" }
        require(core.policies == expectedCore.policies) { "core_flow.policies must match policies" }
    }

    companion object {
        private fun buildAnnexCCore(
            docType: String, requestedElements: Map<String, List<String>>, policies: DefinedVerificationPolicies
        ): GeneralFlowConfig {
            val claims = requestedElements.entries.sortedBy { it.key }.flatMap { (namespace, elements) ->
                elements.distinct().sorted().map { elementId ->
                    ClaimsQuery(path = listOf(namespace, elementId))
                }
            }

            val dcqlQuery = DcqlQuery(
                credentials = listOf(
                    CredentialQuery(
                        id = "annex_c", format = CredentialFormat.MSO_MDOC, meta = MsoMdocMeta(doctypeValue = docType), claims = claims
                    )
                )
            )

            return GeneralFlowConfig(
                dcqlQuery = dcqlQuery, policies = policies
            )
        }

        val EXTENDED_MDL_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "org.iso.18013.5.1.mDL",
            requestedElements = mapOf(
                "org.iso.18013.5.1" to listOf(
                    "family_name",
                    "given_name",
                    "birth_date",
                    "issue_date",
                    "expiry_date",
                    "issuing_country",
                    "issuing_authority",
                    "driving_privileges",

                    "age_birth_year",
                    "age_over_18",
                    "age_over_21",
                    "age_over_65",

                    "issuing_jurisdiction",
                    "nationality"
                )
            ),
            origin = "https://digital-credentials.walt.id",
        )

        val EXTENDED_PHOTOID_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "org.iso.23220.photoid.1",
            requestedElements = mapOf(
                "org.iso.23220.1" to listOf(
                    "family_name",
                    "family_name_viz",
                    "given_name",
                    "given_name_viz",
                    "issue_date",
                    "expiry_date",
                    "issuing_authority_unicode",
                    "issuing_country",
                    "age_over_18",
                    "age_over_21",
                    "age_birth_year",
                    "portrait_capture_date",
                    "birthplace",
                    "name_at_birth",
                    "resident_address",
                    "resident_city",
                    "resident_postal_code",
                    "resident_country",
                    "resident_city_latin1",
                    "nationality",
                    "document_number",
                    "issuing_subdivision",
                    "family_name_latin1",
                    "given_name_latin1"
                ),
                "org.iso.23220.photoid.1" to listOf(
                    "person_id",
                    "birth_country",
                    "birth_state",
                    "birth_city",
                    "administrative_number",
                    "resident_street",
                    "resident_house_number",
                    "travel_document_type",
                    "travel_document_number",
                    "travel_document_mrz",
                    "resident_state"
                )
            ),
            origin = "https://digital-credentials.walt.id",
        )

        val EXTENDED_PID_EXAMPLE = DcApiAnnexCFlowSetup(
            docType = "eu.europa.ec.eudi.pid.1",
            requestedElements = mapOf(
                "eu.europa.ec.eudi.pid.1" to listOf(
                    "family_name",
                    "given_name",
                    "birth_date",
                    "age_birth_year",
                    "age_over_18",
                    "age_over_21",
                    "family_name_birth",
                    "given_name_birth",
                    "birth_place",
                    "birth_country",
                    "issuance_date",
                    "expiry_date",
                    "issuing_authority",
                    "issuing_country"
                )
            ),
            origin = "https://digital-credentials.walt.id",
        )
    }
}
