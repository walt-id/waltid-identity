package id.walt.crypto.keys.jwk

import id.walt.crypto.keys.KeyType
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertTrue
import kotlin.test.assertNotNull

class JWKKeyTest {

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @Nested
    inner class Ed25519KeyType {

        private lateinit var key: JWKKey

        @BeforeAll
        fun setup() = runTest {
            key = JWKKey.generate(KeyType.Ed25519)
        }

        @Nested
        inner class JWKFormat {
            @Test
            fun `should be able to export private key`() = runTest {
                // assertDoesNotThrow doesn't accept a suspend function
                try {
                    key.exportJWK()
                } catch (e: Throwable) {
                    fail("It should be able to export pub/pvt keys in JWK format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {

                // assertDoesNotThrow doesn't accept a suspend function
                try {
                    key.getPublicKey().exportJWK()
                } catch (e: Throwable) {
                    fail("It should be able to export pub keys in JWK format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {

                // Pvt key generate with
                //  > openssl genpkey -algorithm Ed25519 -out private_key.pem
                // and coverted from PEM to JWK with
                //  > https://jwkset.com/generate
                val jwk = """
            {
              "kty": "OKP",
              "alg": "EdDSA",
              "kid": "70e5e3c4-7cd4-45d4-8849-592efeb5d8ef",
              "crv": "Ed25519",
              "x": "CphC6JVicLycXLs5c9X-dS1jjZ_o2bXL01jBMs6h77U",
              "d": "gWoTCmzTaFK-3Lj_I1To5FU5RxZVY-ihgSI4z9lCqes"
            }
            """.trimIndent()

                //assertDoesNotThrow  doesn't work with suspend function
                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Throwable) {
                    fail("It should be able to import pub/pvt key in JWK format")
                }
            }

            @Test
            fun `should be able to import public key`() = runTest {

                // Pvt key generate with
                //  > openssl genpkey -algorithm Ed25519 -out private_key.pem
                // Public key extracted:
                //  > openssl pkey -in private_key.pem -pubout -out public_key.pem
                // and coverted from PEM to JWK with
                //  > https://jwkset.com/generate
                val jwk = """
            {
                "kty": "OKP",
                "alg": "EdDSA",
                "kid": "70e5e3c4-7cd4-45d4-8849-592efeb5d8ef",
                "crv": "Ed25519",
                "x": "CphC6JVicLycXLs5c9X-dS1jjZ_o2bXL01jBMs6h77U"
            }
            """.trimIndent()

                //assertDoesNotThrow  doesn't work with suspend function
                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Throwable) {
                    fail("It should be able to import public key in JWK format")
                }
            }

            @Test
            fun `should be able to import JWK generated by itself`() = runTest {
                val jwkString = key.exportJWK()
                val result = JWKKey.importJWK(jwkString)
                assertTrue(result.isSuccess)
            }
        }

        @Nested
        inner class PEMFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                val pem = key.exportPEM()
                assertNotNull(pem)
                assertInstanceOf(String)
            }

            @Test
            fun `should be able to export public key`() = runTest {
                val pem = key.getPublicKey().exportPEM()
                assertNotNull(pem)
                assertInstanceOf(String)
            }

            @Test
            fun `should be able to import private key`() = runTest {
                val pemString = """
                -----BEGIN PRIVATE KEY-----
                MC4CAQAwBQYDK2VwBCIEIIFqEwps02hSvty4/yNU6ORVOUcWVWPooYEiOM/ZQqnr
                -----END PRIVATE KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pemString)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import public key`() = runTest {
                val pemString = """
                -----BEGIN PUBLIC KEY-----
                MCowBQYDK2VwAyEACphC6JVicLycXLs5c9X+dS1jjZ/o2bXL01jBMs6h77U=
                -----END PUBLIC KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pemString)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import PEM generated by itself`() = runTest {
                val pemString = key.exportPEM()
                val result = JWKKey.importPEM(pemString)

                assertTrue(result.isSuccess)
            }
        }
    }

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @Nested
    inner class RSAKeyTypeTest {

        private lateinit var key: JWKKey

        @BeforeAll
        fun setup() = runTest {
            key = JWKKey.generate(KeyType.RSA)
        }

        @Nested
        inner class JWKFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export RSA private key in JWK format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export RSA public key in JWK format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
                // Converted to JWK with
                //  > https://jwkset.com/generate
                val jwk = """
                {
                  "kty": "RSA",
                  "kid": "70e5e3c4-7cd4-45d4-8849-592efeb5d8ef",
                  "d": "O-qsBuGf1yaDB4Rc8V_vLYdrxQXUiixS4bzR89VCMHaqwpSDROjvnj_7h0aiDmtOpFE--xkK0aSQXFwV1v7cnKcLOYuap5mzhXrTj3NAKB4N0guPT-pyhzaOisSJSPw-59DD6T8PnLT1b8ULv-J3fLYEpok6JfQaMhDw4FBSVNHZlvO0qQ3rcKUUaZivl7-K08Wj3qyXCMDVKK1vK0ik4iyORB72YjYVycq-l404mk8-9TAz8HC9kRGuNI6lRr5FJBW49hDwJV3hqiMWiPzhArorUvrYFHRySJWT5SP-XmrT7tCWeBSgTNFaGCF_pI9Z794_M5TQSAL-aVWDsW382Q",
                  "n": "-eOnApnVVGTpIKuWIq6V5yY9hdeO37mS8pqQ3z3oLX--NC9nqvaXoBIlERNogklkk2an3sQtZgFmrqYkFhowmuQj2an8VnrBl2IwEEWW8arLxaKCtktvfdGAO726bcMzDsEk4iub990bSIlLYNakhxx3dMX7XCWq7hki6ow2bmZeeuPPi9fI4ZP9n6nma0zB6yolROFnXySMNnSooA5yb0L6LPG2IM0fqS3AWTzxWzcVvrbgUiyxZRP71zvsO44O03f9M3AMkzh_pf63SZv10v1gyX0dg2bIAl3UksRofumyKAAQwpvI2ykd6FDREZU88_RWyHM_1-dwgrFFD8Lz1Q",
                  "e": "AQAB",
                  "p": "_RuuxST5Rk0eDoTxJjATtY1BcvO2gcz07KHD4rgEXIVUmDFsCE32CEbrWUEtWx8rkOQkr2XBiy5IuJZViazVj4VLwtnP6b5BCWegoIJ6JOBdm20h1dP3qNuaDiG7ZtgddTFqehnAoxA1WuHI01kwsn8PeTdm8Xw2H8640iQLJQs",
                  "q": "_L6OB44GFvN2Z8-qn5OiDVKpEaXoLDhsdMaILYoTJAqOKOMZEtev9bprMIvUSMs27kA1ktK7h6vPSDwYsefXSiAFoiDmtMN4LZ38EfRVXJHeIgGk9tPBP_pKwZuOmjIZx1BfexWAI4Vk-IjFDeFVJ2LfeNMXpaIMxGXWzp_4Fp8",
                  "dp": "0itxdSxdfP2-Loo_f9k-FGwl46DxdFjPK8qrUJBCttzTwMiRD1hFKtxQwr13Pwnj8B0xRR-2la6qHfRfNMH6V4F0xmh813fuozOUUpPlfsd7kvsMtHSdWm53PrLN3PkphM2yv46wwfZMh5miW7Tc1erh22KgrXbZrpHGMGBTjL8",
                  "dq": "hUQEp78fPuLIwBwjn1i8zcGUHBYawZZOuZQlIb34MbzPEIgOJH1N7oeJFWPlXyynniCFHxG2h-bzuObXLpdMUW1pCv_GJfIbYBI5Y04t5E2VjuDHFs64yv8yg7t-CZf5N7sNXV0M363qe5HCNXtm5wmfQ5oqkc9MZBI-nVyD94k",
                  "qi": "PG7cZs-ex_MBRteSlzRLdIUoVDuoyNzdLfd92S-tc5dF1mU42FNRYt6JswB_XHPbXKcq8lZJCPv33cSMhm4jsHCqY83EEkH8cLaUMgkvt3n4V06eR8E4j1v979cyTtReRzb8UB9JFhlyKdnpGEGEExW22pAYk30FryoVs7Bq6uY"
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import RSA private key in JWK format")
                }
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl pkey -in private_key.pem -pubout -out public_key.pem
                // Converted to JWK with
                //  > https://jwkset.com/generate
                val jwk = """
                {
                  "kty": "RSA",
                  "kid": "70e5e3c4-7cd4-45d4-8849-592efeb5d8ef",
                  "n": "-eOnApnVVGTpIKuWIq6V5yY9hdeO37mS8pqQ3z3oLX--NC9nqvaXoBIlERNogklkk2an3sQtZgFmrqYkFhowmuQj2an8VnrBl2IwEEWW8arLxaKCtktvfdGAO726bcMzDsEk4iub990bSIlLYNakhxx3dMX7XCWq7hki6ow2bmZeeuPPi9fI4ZP9n6nma0zB6yolROFnXySMNnSooA5yb0L6LPG2IM0fqS3AWTzxWzcVvrbgUiyxZRP71zvsO44O03f9M3AMkzh_pf63SZv10v1gyX0dg2bIAl3UksRofumyKAAQwpvI2ykd6FDREZU88_RWyHM_1-dwgrFFD8Lz1Q",
                  "e": "AQAB"
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import RSA public key in JWK format")
                }
            }

            @Test
            fun `should be able to import JWK generated by itself`() = runTest {
                val jwkString = key.exportJWK()
                val result = JWKKey.importJWK(jwkString)
                assertTrue(result.isSuccess)
            }
        }

        @Nested
        inner class PEMFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export RSA private key in PEM format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export RSA public key in PEM format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
                val pem = """
                -----BEGIN PRIVATE KEY-----
                MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD546cCmdVUZOkg
                q5YirpXnJj2F147fuZLympDfPegtf740L2eq9pegEiURE2iCSWSTZqfexC1mAWau
                piQWGjCa5CPZqfxWesGXYjAQRZbxqsvFooK2S2990YA7vbptwzMOwSTiK5v33RtI
                iUtg1qSHHHd0xftcJaruGSLqjDZuZl5648+L18jhk/2fqeZrTMHrKiVE4WdfJIw2
                dKigDnJvQvos8bYgzR+pLcBZPPFbNxW+tuBSLLFlE/vXO+w7jg7Td/0zcAyTOH+l
                /rdJm/XS/WDJfR2DZsgCXdSSxGh+6bIoABDCm8jbKR3oUNERlTzz9FbIcz/X53CC
                sUUPwvPVAgMBAAECggEAO+qsBuGf1yaDB4Rc8V/vLYdrxQXUiixS4bzR89VCMHaq
                wpSDROjvnj/7h0aiDmtOpFE++xkK0aSQXFwV1v7cnKcLOYuap5mzhXrTj3NAKB4N
                0guPT+pyhzaOisSJSPw+59DD6T8PnLT1b8ULv+J3fLYEpok6JfQaMhDw4FBSVNHZ
                lvO0qQ3rcKUUaZivl7+K08Wj3qyXCMDVKK1vK0ik4iyORB72YjYVycq+l404mk8+
                9TAz8HC9kRGuNI6lRr5FJBW49hDwJV3hqiMWiPzhArorUvrYFHRySJWT5SP+XmrT
                7tCWeBSgTNFaGCF/pI9Z794/M5TQSAL+aVWDsW382QKBgQD9G67FJPlGTR4OhPEm
                MBO1jUFy87aBzPTsocPiuARchVSYMWwITfYIRutZQS1bHyuQ5CSvZcGLLki4llWJ
                rNWPhUvC2c/pvkEJZ6Cggnok4F2bbSHV0/eo25oOIbtm2B11MWp6GcCjEDVa4cjT
                WTCyfw95N2bxfDYfzrjSJAslCwKBgQD8vo4HjgYW83Znz6qfk6INUqkRpegsOGx0
                xogtihMkCo4o4xkS16/1umswi9RIyzbuQDWS0ruHq89IPBix59dKIAWiIOa0w3gt
                nfwR9FVckd4iAaT208E/+krBm46aMhnHUF97FYAjhWT4iMUN4VUnYt940xelogzE
                ZdbOn/gWnwKBgQDSK3F1LF18/b4uij9/2T4UbCXjoPF0WM8ryqtQkEK23NPAyJEP
                WEUq3FDCvXc/CePwHTFFH7aVrqod9F80wfpXgXTGaHzXd+6jM5RSk+V+x3uS+wy0
                dJ1abnc+ss3c+SmEzbK/jrDB9kyHmaJbtNzV6uHbYqCtdtmukcYwYFOMvwKBgQCF
                RASnvx8+4sjAHCOfWLzNwZQcFhrBlk65lCUhvfgxvM8QiA4kfU3uh4kVY+VfLKee
                IIUfEbaH5vO45tcul0xRbWkK/8Yl8htgEjljTi3kTZWO4McWzrjK/zKDu34Jl/k3
                uw1dXQzfrep7kcI1e2bnCZ9DmiqRz0xkEj6dXIP3iQKBgDxu3GbPnsfzAUbXkpc0
                S3SFKFQ7qMjc3S33fdkvrXOXRdZlONhTUWLeibMAf1xz21ynKvJWSQj7993EjIZu
                I7BwqmPNxBJB/HC2lDIJL7d5+FdOnkfBOI9b/e/XMk7UXkc2/FAfSRYZcinZ6RhB
                hBMVttqQGJN9Ba8qFbOwaurm
                -----END PRIVATE KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl pkey -in private_key.pem -pubout -out public_key.pem
                val pem = """
                -----BEGIN PUBLIC KEY-----
                MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+eOnApnVVGTpIKuWIq6V
                5yY9hdeO37mS8pqQ3z3oLX++NC9nqvaXoBIlERNogklkk2an3sQtZgFmrqYkFhow
                muQj2an8VnrBl2IwEEWW8arLxaKCtktvfdGAO726bcMzDsEk4iub990bSIlLYNak
                hxx3dMX7XCWq7hki6ow2bmZeeuPPi9fI4ZP9n6nma0zB6yolROFnXySMNnSooA5y
                b0L6LPG2IM0fqS3AWTzxWzcVvrbgUiyxZRP71zvsO44O03f9M3AMkzh/pf63SZv1
                0v1gyX0dg2bIAl3UksRofumyKAAQwpvI2ykd6FDREZU88/RWyHM/1+dwgrFFD8Lz
                1QIDAQAB
                -----END PUBLIC KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import PEM generated by itself`() = runTest {
                val pemString = key.exportPEM()

                val result = JWKKey.importPEM(pemString)
                assertTrue(result.isSuccess)
            }
        }

    }

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @Nested
    inner class Secp256k1KeyTypeTest {

        private lateinit var key: JWKKey

        @BeforeAll
        fun setup() = runTest {
            key = JWKKey.generate(KeyType.secp256k1)
        }

        @Nested
        inner class JWKFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export secp256k1 private key in JWK format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export secp256k1 public key in JWK format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl ecparam -name secp256k1 -genkey -noout -out private_key.pem
                // Converted to JWK with
                //  > https://pem2jwk.vercel.app/
                val jwk = """
                {
                  "keys": [
                    {
                      "kty": "EC",
                      "crv": "secp256k1",
                      "x": "cYcEC83heFKRMHgiPckJ7Awt0uf6ZGo_qhjFL8yPkbk",
                      "y": "qcdBRuGUMTWovbJFDClbpxYVjwGF3wLjuYeddV8AJYc",
                      "ext": true,
                      "d": "jrA04vDF2bRETWehJFuNKXp_I-wcdS51YUs4VW90ds0",
                      "kid": "898ed47c11fd1e50b8f50969f",
                      "alg": "RS256",
                      "use": "sig"
                    }
                  ]
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import secp256k1 private key in JWK format")
                }
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl ec -in private_key.pem -pubout -out public_key.pem
                // Converted to JWK with
                //  > https://pem2jwk.vercel.app/
                val jwk = """
                {
                  "keys": [
                    {
                      "kty": "EC",
                      "crv": "secp256k1",
                      "x": "LQEX880TgRiaYuOzHZaHI7-3_cOeGp8n9rNYZjiRj0c",
                      "y": "zrMZHN9JPg-BaZMtm5E5nTdSlPmVzN-RiRO811hjEaQ",
                      "ext": true,
                      "kid": "d9c821eb1717ea2eecc554541bf",
                      "alg": "RS256",
                      "use": "sig"
                    }
                  ]
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import secp256k1 public key in JWK format")
                }
            }

            @Test
            fun `should be able to import JWK generated by itself`() = runTest {
                val jwkString = key.exportJWK()
                val result = JWKKey.importJWK(jwkString)
                assertTrue(result.isSuccess)
            }
        }

        @Nested
        inner class PEMFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export secp256k1 private key in PEM format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export secp256k1 public key in PEM format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl ecparam -name secp256k1 -genkey -noout -out private_key.pem
                val pem = """
                -----BEGIN EC PRIVATE KEY-----
                MHQCAQEEII6wNOLwxdm0RE1noSRbjSl6fyPsHHUudWFLOFVvdHbNoAcGBSuBBAAK
                oUQDQgAEcYcEC83heFKRMHgiPckJ7Awt0uf6ZGo/qhjFL8yPkbmpx0FG4ZQxNai9
                skUMKVunFhWPAYXfAuO5h511XwAlhw==
                -----END EC PRIVATE KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl ec -in private_key.pem -pubout -out public_key.pem
                val pem = """
                -----BEGIN PUBLIC KEY-----
                MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEcYcEC83heFKRMHgiPckJ7Awt0uf6ZGo/
                qhjFL8yPkbmpx0FG4ZQxNai9skUMKVunFhWPAYXfAuO5h511XwAlhw==
                -----END PUBLIC KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import PEM generated by itself`() = runTest {
                val pemString = key.exportPEM()

                val result = JWKKey.importPEM(pemString)
                assertTrue(result.isSuccess)
            }
        }
    }

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @Nested
    inner class Secp256r1KeyTypeTest {

        private lateinit var key: JWKKey

        @BeforeAll
        fun setup() = runTest {
            key = JWKKey.generate(KeyType.secp256r1)
        }

        @Nested
        inner class JWKFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export secp256r1 private key in JWK format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportJWK()
                } catch (e: Exception) {
                    fail("It should be able to export secp256r1 public key in JWK format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl ecparam -name secp256r1 -genkey -noout -out private_key.pem
                // Converted to JWK with
                //  > https://pem2jwk.vercel.app/
                val jwk = """
                {
                  "keys": [
                    {
                      "kty": "EC",
                      "crv": "p256",
                      "x": "20U-Zvrlqp1m0psn4BD9m1SvZjfUIt2BEX6biLglBpc",
                      "y": "WXncPDNHXD_4-j_IItht9Cl9A9_khRnzazp9sAXOTC8",
                      "ext": true,
                      "d": "si5F8eQ6ttEZCaMh-2EkOJxRQj7YPs6mL49Xm3sxLoo",
                      "kid": "820119b503a2b16dc5520f",
                      "alg": "RS256",
                      "use": "sig"
                    }
                  ]
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import secp256r1 private key in JWK format")
                }
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl ec -in private_key.pem -pubout -out public_key.pem
                // Converted to JWK with
                //  > https://pem2jwk.vercel.app/
                val jwk = """
                {
                  "keys": [
                    {
                      "kty": "EC",
                      "crv": "p256",
                      "x": "ftUiAOdV9Sb1LwI2XkWC6W3a_qqBkwELyeBXki-b8Uc",
                      "y": "G9ESP-tJmOseh-symTtR-jr4clsLOjCWbxSUN2lUvM0",
                      "ext": true,
                      "kid": "e76b9d2617b6fece0bec",
                      "alg": "RS256",
                      "use": "sig"
                    }
                  ]
                }
                """.trimIndent()

                try {
                    JWKKey.importJWK(jwk)
                } catch (e: Exception) {
                    fail("It should be able to import secp256r1 public key in JWK format")
                }
            }

            @Test
            fun `should be able to import JWK generated by itself`() = runTest {
                val jwkString = key.exportJWK()
                val result = JWKKey.importJWK(jwkString)
                assertTrue(result.isSuccess)
            }
        }

        @Nested
        inner class PEMFormat {

            @Test
            fun `should be able to export private key`() = runTest {
                try {
                    key.exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export secp256r1 private key in PEM format")
                }
            }

            @Test
            fun `should be able to export public key`() = runTest {
                try {
                    key.getPublicKey().exportPEM()
                } catch (e: Exception) {
                    fail("It should be able to export secp256r1 public key in PEM format")
                }
            }

            @Test
            fun `should be able to import private key`() = runTest {
                // Generated with:
                //  > openssl ecparam -name secp256r1 -genkey -noout -out private_key.pem
                val pem = """
                -----BEGIN EC PRIVATE KEY-----
                MHcCAQEEILIuRfHkOrbRGQmjIfthJDicUUI+2D7Opi+PV5t7MS6KoAoGCCqGSM49
                AwEHoUQDQgAEkmLmxzmbCxj6FExyJ2eT5+VjpMXN8MdlMKD0jZtb7BPkz4+VMbZ/
                8qwhdanxj0imZ+t740kEWu6h5hrElcmEIg==
                -----END EC PRIVATE KEY-----

                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import public key`() = runTest {
                // Generated with:
                //  > openssl ec -in private_key.pem -pubout -out public_key.pem
                val pem = """
                -----BEGIN PUBLIC KEY-----
                MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEkmLmxzmbCxj6FExyJ2eT5+VjpMXN
                8MdlMKD0jZtb7BPkz4+VMbZ/8qwhdanxj0imZ+t740kEWu6h5hrElcmEIg==
                -----END PUBLIC KEY-----
                """.trimIndent()

                val result = JWKKey.importPEM(pem)
                assertTrue(result.isSuccess)
            }

            @Test
            fun `should be able to import PEM generated by itself`() = runTest {
                val pemString = key.exportPEM()

                val result = JWKKey.importPEM(pemString)
                assertTrue(result.isSuccess)
            }
        }
    }
}