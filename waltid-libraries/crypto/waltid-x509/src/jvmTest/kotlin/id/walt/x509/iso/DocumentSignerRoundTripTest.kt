@file:OptIn(ExperimentalTime::class)

package id.walt.x509.iso

import id.walt.crypto.keys.KeyGenerationRequest
import id.walt.crypto.keys.KeyManager
import id.walt.crypto.keys.KeyType
import id.walt.x509.iso.documentsigner.builder.DocumentSignerCertificateBuilder
import id.walt.x509.iso.documentsigner.builder.IACASignerSpecification
import id.walt.x509.iso.documentsigner.certificate.DocumentSignerPrincipalName
import id.walt.x509.iso.documentsigner.parser.DocumentSignerCertificateParser
import id.walt.x509.iso.iaca.builder.IACACertificateBuilder
import id.walt.x509.iso.iaca.certificate.IACACertificateProfileData
import id.walt.x509.iso.iaca.certificate.IACAPrincipalName
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.time.*
import kotlin.time.Duration.Companion.days

class DocumentSignerRoundTripTest {

    private val iacaSigningKey = runBlocking {
        KeyManager.createKey(
            generationRequest = KeyGenerationRequest(
                backend = "jwk",
                keyType = KeyType.secp256r1,
            )
        )
    }

    private val iacaValidNotBefore = Instant.fromEpochSeconds(Clock.System.now().epochSeconds)
    private val iacaValidNotAfter = iacaValidNotBefore.plus((365).toDuration(DurationUnit.DAYS))

    private val dsKey = runBlocking {
        KeyManager.createKey(
            generationRequest = KeyGenerationRequest(
                backend = "jwk",
                keyType = KeyType.secp256r1,
            )
        )
    }

    @Test
    fun `parser should correctly parse Document Signer certificate generated by builder`() = runTest {
        val issuerAlternativeName = IssuerAlternativeName(
            uri = "https://ca.example.com",
        )
        val iacaCertBuilder = IACACertificateBuilder(
            profileData = IACACertificateProfileData(
                principalName = IACAPrincipalName(
                    country = "US",
                    commonName = "Example IACA",
                ),
                validityPeriod = CertificateValidityPeriod(
                    notBefore = iacaValidNotBefore,
                    notAfter = iacaValidNotAfter,
                ),
                issuerAlternativeName = issuerAlternativeName,
                crlDistributionPointUri = "https://ca.example.com/crl",
            ),
            signingKey = iacaSigningKey,
        )

        val iacaCertBundle = iacaCertBuilder.build()

        val dsCertBuilder = DocumentSignerCertificateBuilder(
            principalName = DocumentSignerPrincipalName(
                country = "US",
                commonName = "Example DS",
            ),
            validityPeriod = CertificateValidityPeriod(
                notBefore = iacaValidNotBefore.plus(1.days),
                notAfter = iacaValidNotAfter.minus(1.days),
            ),
            crlDistributionPointUri = "https://ca.example.com/crl",
            documentSignerPublicKey = dsKey.getPublicKey(),
            iacaSignerSpec = IACASignerSpecification(
                signingKey = iacaSigningKey,
                data = iacaCertBundle.decodedData.toIACACertificateProfileData(),
            )
        )

        val dsCertificateBundle = dsCertBuilder.build()

        val dsCertParser = DocumentSignerCertificateParser(
            certificate = dsCertificateBundle.certificateDer,
        )

        val decodedCert = dsCertParser.parse()

        assertEquals(
            expected = dsCertificateBundle.data,
            actual = decodedCert,
        )
    }
}
