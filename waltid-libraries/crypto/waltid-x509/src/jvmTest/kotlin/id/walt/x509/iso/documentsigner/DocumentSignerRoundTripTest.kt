@file:OptIn(ExperimentalTime::class)

package id.walt.x509.iso.documentsigner

import id.walt.crypto.keys.KeyGenerationRequest
import id.walt.crypto.keys.KeyManager
import id.walt.crypto.keys.KeyType
import id.walt.x509.iso.CertificateValidityPeriod
import id.walt.x509.iso.IssuerAlternativeName
import id.walt.x509.iso.documentsigner.builder.DocumentSignerCertificateBuilder
import id.walt.x509.iso.documentsigner.builder.IACASignerSpecification
import id.walt.x509.iso.documentsigner.certificate.DocumentSignerCertificateProfileData
import id.walt.x509.iso.documentsigner.certificate.DocumentSignerPrincipalName
import id.walt.x509.iso.documentsigner.parser.DocumentSignerCertificateParser
import id.walt.x509.iso.iaca.builder.IACACertificateBuilder
import id.walt.x509.iso.iaca.certificate.IACACertificateProfileData
import id.walt.x509.iso.iaca.certificate.IACAPrincipalName
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.time.*
import kotlin.time.Duration.Companion.days

class DocumentSignerRoundTripTest {

    private val iacaSigningKey = runBlocking {
        KeyManager.createKey(
            generationRequest = KeyGenerationRequest(
                backend = "jwk",
                keyType = KeyType.secp256r1,
            )
        )
    }

    private val iacaValidNotBefore = Instant.fromEpochSeconds(Clock.System.now().epochSeconds)
    private val iacaValidNotAfter = iacaValidNotBefore.plus((365).toDuration(DurationUnit.DAYS))

    private val dsKey = runBlocking {
        KeyManager.createKey(
            generationRequest = KeyGenerationRequest(
                backend = "jwk",
                keyType = KeyType.secp256r1,
            )
        )
    }

    @Test
    fun `parser should correctly parse Document Signer certificate generated by builder`() = runTest {
        val issuerAlternativeName = IssuerAlternativeName(
            uri = "https://ca.example.com",
        )
        val iacaProfileData = IACACertificateProfileData(
            principalName = IACAPrincipalName(
                country = "US",
                commonName = "Example IACA",
            ),
            validityPeriod = CertificateValidityPeriod(
                notBefore = iacaValidNotBefore,
                notAfter = iacaValidNotAfter,
            ),
            issuerAlternativeName = issuerAlternativeName,
            crlDistributionPointUri = "https://ca.example.com/crl",
        )

        val iacaCertBuilder = IACACertificateBuilder()
        val iacaCertBundle = iacaCertBuilder.build(
            profileData = iacaProfileData,
            signingKey = iacaSigningKey,
        )

        val dsProfileData = DocumentSignerCertificateProfileData(
            principalName = DocumentSignerPrincipalName(
                country = "US",
                commonName = "Example DS",
            ),
            validityPeriod = CertificateValidityPeriod(
                notBefore = iacaValidNotBefore.plus(1.days),
                notAfter = iacaValidNotAfter.minus(1.days),
            ),
            crlDistributionPointUri = "https://ca.example.com/crl",
        )

        val dsCertBuilder = DocumentSignerCertificateBuilder()
        val dsCertificateBundle = dsCertBuilder.build(
            profileData = dsProfileData,
            publicKey = dsKey.getPublicKey(),
            iacaSignerSpec = IACASignerSpecification(
                signingKey = iacaSigningKey,
                profileData = iacaCertBundle.decodedCertificate.toIACACertificateProfileData(),
            ),
        )

        val dsCertParser = DocumentSignerCertificateParser()

        val decodedCert = dsCertParser.parse(
            certificate = dsCertificateBundle.certificateDer,
        )

        assertEquals(
            expected = dsCertificateBundle.decodedCertificate,
            actual = decodedCert,
        )

    }
}
