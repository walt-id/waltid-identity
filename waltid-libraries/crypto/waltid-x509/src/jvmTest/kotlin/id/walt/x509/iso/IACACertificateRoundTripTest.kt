@file:OptIn(ExperimentalTime::class)

package id.walt.x509.iso

import id.walt.crypto.keys.KeyGenerationRequest
import id.walt.crypto.keys.KeyManager
import id.walt.crypto.keys.KeyType
import id.walt.x509.iso.iaca.builder.IACACertificateBuilder
import id.walt.x509.iso.iaca.parser.IACACertificateParser
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.time.Clock
import kotlin.time.DurationUnit
import kotlin.time.ExperimentalTime
import kotlin.time.toDuration

class IACACertificateRoundTripTest {

    private val signingKey = runBlocking {
        KeyManager.createKey(
            generationRequest = KeyGenerationRequest(
                backend = "jwk",
                keyType = KeyType.secp256r1,
            )
        )
    }

    private val validNotBefore = Clock.System.now()
    private val validNotAfter = validNotBefore.plus((365).toDuration(DurationUnit.DAYS))

    @Test
    fun `parser should correctly parse IACA certificate generated by builder`() = runTest {

        val issuerAlternativeName = IssuerAlternativeName(
            uri = "https://ca.example.com",
        )
        val iacaCertBuilder = IACACertificateBuilder(
            country = "US",
            commonName = "Example IACA",
            notBefore = validNotBefore,
            notAfter = validNotAfter,
            issuerAlternativeName = issuerAlternativeName,
            signingKey = signingKey,
        ).apply {
            crlDistributionPointUri = "https://ca.example.com/crl"
        }

        val iacaCertBundle = iacaCertBuilder.build()

        val iacaCertParser = IACACertificateParser(
            certificate = iacaCertBundle.certificateDer,
        )

        val decodedCert = iacaCertParser.parse()

        assertEquals(
            expected = iacaCertBundle.decodedData,
            actual = decodedCert,
        )

    }
}